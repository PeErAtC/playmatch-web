// pages/MatchDetails.js
import React, { useState, useEffect, useCallback, useRef } from "react";
import { useRouter } from "next/router";
import { db } from "../lib/firebaseConfig";
import {
  doc,
  getDoc,
  collection,
  query,
  where,
  getDocs,
  writeBatch,
  serverTimestamp,
  updateDoc,
  setDoc,
} from "firebase/firestore";
import Swal from "sweetalert2";
import * as XLSX from "xlsx";
import { saveAs } from "file-saver";
import html2canvas from "html2canvas";

// Helper function to format date
const formatDate = (dateString) => {
  if (!dateString) return "";
  try {
    const d = new Date(dateString);
    if (isNaN(d.getTime())) {
      return dateString;
    }
    return `${d.getDate().toString().padStart(2, "0")}/${(d.getMonth() + 1)
      .toString()
      .padStart(2, "0")}/${d.getFullYear()}`;
  } catch (e) {
    console.error("Invalid date string:", dateString, e);
    return dateString;
  }
};

// ADDED: Helper function to get MVP icon based on rank
const getMvpIcon = (rank) => {
  switch (rank) {
    case 1:
      return "üèÜ"; // Gold Trophy
    case 2:
      return "ü•à"; // Silver Medal
    case 3:
      return "ü•â"; // Bronze Medal
    default:
      return "ü•â"; // Generic Medal for 4th onwards
  }
};


const MatchDetails = () => {
  const router = useRouter();
  const { matchId } = router.query;
  const [matchData, setMatchData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [courtFee, setCourtFee] = useState("");
  const [courtFeePerGame, setCourtFeePerGame] = useState("");
  const [fixedCourtFeePerPerson, setFixedCourtFeePerPerson] = useState("");
  const [isRankingSaved, setIsRankingSaved] = useState(false);
  const [ballPrice, setBallPrice] = useState("");
  const [organizeFee, setOrganizeFee] = useState("");
  const [memberCalculations, setMemberCalculations] = useState({});
  const [loggedInEmail, setLoggedInEmail] = useState("");
  const [adminEmail, setAdminEmail] = useState("");
  const [isDataCalculated, setIsDataCalculated] = useState(false);
  const [isSavingRanking, setIsSavingRanking] = useState(false);
  const [memberPaidStatus, setMemberPaidStatus] = useState({});
  const [isPaymentHistorySaved, setIsPaymentHistorySaved] = useState(false);
  const [showDateInDownloadImage, setShowDateInDownloadImage] = useState(false);
  const [earlyPayersList, setEarlyPayersList] = useState([]);
  const [availableCoupons, setAvailableCoupons] = useState([]);
  const [currentCouponSelection, setCurrentCouponSelection] = useState({ id: "", amount: 0, reason: "" });
  const [currentMemberSelection, setCurrentMemberSelection] = useState("");
  const [appliedCoupons, setAppliedCoupons] = useState([]);

  // ADDED: State for number of MVPs
  const [mvpCount, setMvpCount] = useState(1);

  const tableRef = useRef(null);
  const gameDetailsTableRef = useRef(null);

  const Toast = Swal.mixin({
    toast: true,
    position: 'top-end',
    showConfirmButton: false,
    timer: 3000,
    timerProgressBar: true,
    didOpen: (toast) => {
      toast.addEventListener('mouseenter', Swal.stopTimer);
      toast.addEventListener('mouseleave', Swal.resumeTimer);
    }
  });

  useEffect(() => {
    if (typeof window !== "undefined") {
      setLoggedInEmail(localStorage.getItem("loggedInEmail") || "");
      const fetchAdminEmail = async () => {
        try {
          const configDocRef = doc(db, "configurations", "appConfig");
          const configSnap = await getDoc(configDocRef);
          if (configSnap.exists() && configSnap.data().adminEmail) {
            setAdminEmail(configSnap.data().adminEmail);
          } else {
            setAdminEmail("admin@example.com");
          }
        } catch (err) {
          console.error("Error fetching admin email:", err);
          setAdminEmail("admin@example.com");
        }
      };
      fetchAdminEmail();
    }
  }, []);

  const fetchCoupons = useCallback(async () => {
    if (!loggedInEmail) return;
    try {
      const usersRef = collection(db, "users");
      const userQuery = query(usersRef, where("email", "==", loggedInEmail));
      const userSnap = await getDocs(userQuery);
      let userId = null;
      userSnap.forEach((doc) => { userId = doc.id; });

      if (!userId) {
        setAvailableCoupons([]);
        return;
      }

      const couponsRef = collection(db, `users/${userId}/Coupons`);
      const q = query(couponsRef, where("status", "==", "ACTIVE"));
      const querySnapshot = await getDocs(q);
      const couponsData = querySnapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      }));

      const now = new Date();
      const validCoupons = couponsData.filter(coupon =>
          coupon.expiresAt && coupon.expiresAt.toDate() > now
      );

      setAvailableCoupons(validCoupons);

    } catch (err) {
      console.error("Error fetching coupons:", err);
      setAvailableCoupons([]);
    }
  }, [loggedInEmail]);

  useEffect(() => {
    fetchCoupons();
  }, [fetchCoupons]);

  const isAdmin = loggedInEmail && adminEmail && loggedInEmail === adminEmail;

  const calculateMemberStats = useCallback(
    (
      currentMatchData,
      currentCourtFee,
      currentBallPrice,
      currentOrganizeFee,
      currentCourtFeePerGame,
      currentFixedCourtFeePerPerson,
      currentAppliedCoupons,
      loadedEarlyPayers
    ) => {
      if (!currentMatchData || !currentBallPrice || !currentOrganizeFee || !currentMatchData.matches || currentMatchData.matches.length === 0) {
        setMemberCalculations({});
        setIsDataCalculated(false);
        return;
      }

      const parsedCourtFee = parseFloat(currentCourtFee);
      const parsedCourtFeePerGame = parseFloat(currentCourtFeePerGame);
      const parsedFixedCourtFeePerPerson = parseFloat(currentFixedCourtFeePerPerson);
      const parsedBallPrice = parseFloat(currentBallPrice);
      const parsedOrganizeFee = parseFloat(currentOrganizeFee);

      const isCourtFeeValid = !isNaN(parsedCourtFee) && parsedCourtFee >= 0;
      const isCourtFeePerGameValid = !isNaN(parsedCourtFeePerGame) && parsedCourtFeePerGame >= 0;
      const isFixedCourtFeePerPersonValid = !isNaN(parsedFixedCourtFeePerPerson) && parsedFixedCourtFeePerPerson >= 0;

      if (!isCourtFeeValid && !isCourtFeePerGameValid && !isFixedCourtFeePerPersonValid) {
        setMemberCalculations({});
        setIsDataCalculated(false);
        return;
      }

      if (isNaN(parsedBallPrice) || isNaN(parsedOrganizeFee) || parsedBallPrice < 0 || parsedOrganizeFee < 0) {
        setMemberCalculations({});
        setIsDataCalculated(false);
        return;
      }

      const playersInMatch = new Set();
      currentMatchData.matches.forEach((game) => {
        if (game.A1) playersInMatch.add(game.A1);
        if (game.A2) playersInMatch.add(game.A2);
        if (game.B1) playersInMatch.add(game.B1);
        if (game.B2) playersInMatch.add(game.B2);
      });

      const tempMemberCalculations = {};
      const memberWinsInMatch = {};
      const memberDrawsInMatch = {};
      const memberGamesPlayed = {};
      const memberBallsUsed = {};
      const memberScoresInMatch = {};
      const initialPaidStatus = { ...currentMatchData.paidStatus };

      playersInMatch.forEach((player) => {
        tempMemberCalculations[player] = { name: player, level: "", totalGames: 0, totalBalls: 0, wins: 0, draws: 0, score: 0, ballCost: 0, courtCostPerPerson: 0, organizeFeePerPerson: parsedOrganizeFee, total: 0, calculatedWins: 0, calculatedDraws: 0, calculatedScore: 0, isPaid: loadedEarlyPayers.includes(player) || initialPaidStatus[player] || false, couponAmountUsed: 0, couponIdUsed: null };
        memberWinsInMatch[player] = 0;
        memberDrawsInMatch[player] = 0;
        memberGamesPlayed[player] = 0;
        memberBallsUsed[player] = 0;
        memberScoresInMatch[player] = 0;
      });

      currentMatchData.matches.forEach((game) => {
        const setLevel = (player, levelKey) => { if (player && tempMemberCalculations[player] && game[levelKey] && !tempMemberCalculations[player].level) { tempMemberCalculations[player].level = game[levelKey]; } };
        setLevel(game.A1, "A1Level");
        setLevel(game.A2, "A2Level");
        setLevel(game.B1, "B1Level");
        setLevel(game.B2, "B2Level");
      });

      currentMatchData.matches.forEach((game) => {
        const teamA = [game.A1, game.A2].filter(Boolean);
        const teamB = [game.B1, game.B2].filter(Boolean);
        const allPlayersInGame = [...teamA, ...teamB];
        allPlayersInGame.forEach((player) => {
          memberGamesPlayed[player] = (memberGamesPlayed[player] || 0) + 1;
          memberBallsUsed[player] = (memberBallsUsed[player] || 0) + (parseInt(game.balls) || 0);
        });
        if (game.result === "A") {
          teamA.forEach((player) => {
            memberWinsInMatch[player] = (memberWinsInMatch[player] || 0) + 1;
            memberScoresInMatch[player] = (memberScoresInMatch[player] || 0) + 2;
          });
        } else if (game.result === "B") {
          teamB.forEach((player) => {
            memberWinsInMatch[player] = (memberWinsInMatch[player] || 0) + 1;
            memberScoresInMatch[player] = (memberScoresInMatch[player] || 0) + 2;
          });
        } else if (game.result === "DRAW") {
          allPlayersInGame.forEach((player) => {
            memberScoresInMatch[player] = (memberScoresInMatch[player] || 0) + 1;
            memberDrawsInMatch[player] = (memberDrawsInMatch[player] || 0) + 1;
          });
        }
      });

      if (isFixedCourtFeePerPersonValid && parsedFixedCourtFeePerPerson > 0) {
        playersInMatch.forEach((player) => { tempMemberCalculations[player].courtCostPerPerson = Math.ceil(parsedFixedCourtFeePerPerson); });
      } else if (isCourtFeePerGameValid && parsedCourtFeePerGame > 0) {
        playersInMatch.forEach((player) => {
          const gamesPlayed = memberGamesPlayed[player] || 0;
          tempMemberCalculations[player].courtCostPerPerson = Math.ceil(gamesPlayed * parsedCourtFeePerGame);
        });
      } else if (isCourtFeeValid) {
        const totalPlayersForCourtFee = playersInMatch.size;
        const courtCostPerPersonCalculated = totalPlayersForCourtFee > 0 ? Math.ceil(parsedCourtFee / totalPlayersForCourtFee) : 0;
        playersInMatch.forEach((player) => { tempMemberCalculations[player].courtCostPerPerson = courtCostPerPersonCalculated; });
      }

      playersInMatch.forEach((player) => {
        const ballsUsed = memberBallsUsed[player] || 0;
        const calculatedWins = memberWinsInMatch[player] || 0;
        const calculatedDraws = memberDrawsInMatch[player] || 0;
        const totalGames = memberGamesPlayed[player] || 0;
        const calculatedScore = memberScoresInMatch[player] || 0;
        const ballCost = ballsUsed * parsedBallPrice;
        const roundedBallCost = Math.ceil(ballCost);
        const roundedOrganizeFee = Math.ceil(parsedOrganizeFee);
        const playerCourtCost = tempMemberCalculations[player].courtCostPerPerson;
        let totalMemberCost = roundedBallCost + playerCourtCost + roundedOrganizeFee;

        const couponAppliedToThisMember = currentAppliedCoupons.find((coupon) => coupon.memberName === player);
        if (couponAppliedToThisMember) {
          totalMemberCost = Math.max(0, totalMemberCost - couponAppliedToThisMember.amount);
          tempMemberCalculations[player].couponAmountUsed = couponAppliedToThisMember.amount;
          tempMemberCalculations[player].couponIdUsed = couponAppliedToThisMember.couponId;
        }

        tempMemberCalculations[player] = {
          ...tempMemberCalculations[player],
          totalGames,
          totalBalls: ballsUsed,
          wins: calculatedWins,
          draws: calculatedDraws,
          score: calculatedScore,
          ballCost: roundedBallCost,
          courtCostPerPerson: playerCourtCost,
          organizeFeePerPerson: roundedOrganizeFee,
          total: totalMemberCost,
          calculatedWins,
          calculatedDraws,
          calculatedScore,
        };
      });

      const newPaidStatus = {};
      Object.values(tempMemberCalculations).forEach((member) => { newPaidStatus[member.name] = member.isPaid; });
      setMemberPaidStatus(newPaidStatus);

      setMemberCalculations(tempMemberCalculations);
      setIsDataCalculated(true);
    },
    []
  );

  const fetchMatchAndMemberDetails = useCallback(async () => {
    if (!matchId || !loggedInEmail) { return; }
    setLoading(true);
    setError(null);
    try {
      const usersRef = collection(db, "users");
      const userQuery = query(usersRef, where("email", "==", loggedInEmail));
      const userSnap = await getDocs(userQuery);
      let userId = null;
      userSnap.forEach((doc) => { userId = doc.id; });
      if (!userId) { throw new Error("User data not found. Please log in again."); }
      const matchDocRef = doc(db, `users/${userId}/Matches`, matchId);
      const matchSnap = await getDoc(matchDocRef);
      if (!matchSnap.exists()) {
        setError("Match data not found.");
        setLoading(false);
        return;
      }
      const data = matchSnap.data();
      setMatchData(data);
      const loadedEarlyPayers = data.earlyPayers || [];
      setEarlyPayersList(loadedEarlyPayers);
      const loadedCourtFee = data.courtFee != null ? String(data.courtFee) : "";
      const loadedCourtFeePerGame = data.courtFeePerGame != null ? String(data.courtFeePerGame) : "";
      const loadedFixedCourtFeePerPerson = data.fixedCourtFeePerPerson != null ? String(data.fixedCourtFeePerPerson) : "";
      const loadedBallPrice = data.ballPrice != null ? String(data.ballPrice) : "";
      const loadedOrganizeFee = data.organizeFee != null ? String(data.organizeFee) : "";
      setCourtFee(loadedCourtFee);
      setCourtFeePerGame(loadedCourtFeePerGame);
      setFixedCourtFeePerPerson(loadedFixedCourtFeePerPerson);
      setBallPrice(loadedBallPrice);
      setOrganizeFee(loadedOrganizeFee);
      setMemberPaidStatus(data.paidStatus || {});
      setIsRankingSaved(!!data.hasRankingSaved);
      setIsPaymentHistorySaved(!!data.hasPaymentHistorySaved);
      const loadedAppliedCoupons = data.appliedCouponsDetails || [];
      setAppliedCoupons(loadedAppliedCoupons);
      if (data.matches && data.matches.length > 0) {
        calculateMemberStats(data, loadedCourtFee, loadedBallPrice, loadedOrganizeFee, loadedCourtFeePerGame, loadedFixedCourtFeePerPerson, loadedAppliedCoupons, loadedEarlyPayers);
      } else {
        setMemberCalculations({});
        setIsDataCalculated(false);
      }
    } catch (err) {
      console.error("Error fetching match or member details:", err);
      setError("Cannot fetch match or member details: " + err.message);
      Swal.fire("Error", "Cannot fetch match or member details: " + err.message, "error");
    } finally {
      setLoading(false);
    }
  }, [matchId, loggedInEmail, calculateMemberStats]);

  useEffect(() => {
    fetchMatchAndMemberDetails();
  }, [fetchMatchAndMemberDetails]);

  const handleCourtFeeChange = (e) => {
    const value = e.target.value;
    setCourtFee(value);
    if (value !== "") {
      setCourtFeePerGame("");
      setFixedCourtFeePerPerson("");
    }
  };

  const handleCourtFeePerGameChange = (e) => {
    const value = e.target.value;
    setCourtFeePerGame(value);
    if (value !== "") {
      setCourtFee("");
      setFixedCourtFeePerPerson("");
    }
  };

  const handleFixedCourtFeePerPersonChange = (e) => {
    const value = e.target.value;
    setFixedCourtFeePerPerson(value);
    if (value !== "") {
      setCourtFee("");
      setCourtFeePerGame("");
    }
  };

  const handleAddCoupon = () => {
    if (!currentCouponSelection.id || !currentMemberSelection) {
      Swal.fire("Missing Selection", "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ñ‡∏π‡∏õ‡∏≠‡∏á‡πÅ‡∏•‡∏∞‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡∏Ñ‡∏π‡∏õ‡∏≠‡∏á", "warning");
      return;
    }
    const memberAlreadyHasCoupon = appliedCoupons.some((coupon) => coupon.memberName === currentMemberSelection);
    if (memberAlreadyHasCoupon) {
      Swal.fire("Duplicate Coupon", `${currentMemberSelection} ‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏Ñ‡∏π‡∏õ‡∏≠‡∏á‡πÅ‡∏•‡πâ‡∏ß‡πÉ‡∏ô‡πÄ‡∏ã‡∏™‡∏ä‡∏±‡∏ô‡∏ô‡∏µ‡πâ`, "warning");
      return;
    }
    const couponIdAlreadyApplied = appliedCoupons.some((coupon) => coupon.couponId === currentCouponSelection.id);
    if (couponIdAlreadyApplied) {
        Swal.fire("‡∏Ñ‡∏π‡∏õ‡∏≠‡∏á‡∏ñ‡∏π‡∏Å‡πÉ‡∏ä‡πâ‡πÅ‡∏•‡πâ‡∏ß", `‡∏Ñ‡∏π‡∏õ‡∏≠‡∏á ${currentCouponSelection.reason} ‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß‡∏Å‡∏±‡∏ö‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å‡∏Ñ‡∏ô‡∏≠‡∏∑‡πà‡∏ô‡πÉ‡∏ô‡πÄ‡∏ã‡∏™‡∏ä‡∏±‡∏ô‡∏ô‡∏µ‡πâ`, "warning");
        return;
    }
    setAppliedCoupons((prev) => [...prev, { couponId: currentCouponSelection.id, amount: currentCouponSelection.amount, reason: currentCouponSelection.reason, memberName: currentMemberSelection }]);
    setCurrentCouponSelection({ id: "", amount: 0, reason: "" });
    setCurrentMemberSelection("");
    Toast.fire({ icon: 'success', title: `‡∏Ñ‡∏π‡∏õ‡∏≠‡∏á ${currentCouponSelection.reason} ‡∏ñ‡∏π‡∏Å‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÉ‡∏´‡πâ ${currentMemberSelection}` });
  };

  const handleRemoveAppliedCoupon = async (indexToRemove) => {
    const couponToRemove = appliedCoupons[indexToRemove];
    if (!couponToRemove) return;
    const updatedAppliedCoupons = appliedCoupons.filter((_, index) => index !== indexToRemove);
    setAppliedCoupons(updatedAppliedCoupons);
    Toast.fire({ icon: 'info', title: `‡∏•‡∏ö‡∏Ñ‡∏π‡∏õ‡∏≠‡∏á ${couponToRemove.reason} ‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÅ‡∏•‡πâ‡∏ß` });
    try {
        const usersRef = collection(db, "users");
        const userQuery = query(usersRef, where("email", "==", loggedInEmail));
        const userSnap = await getDocs(userQuery);
        let userId = null;
        userSnap.forEach((doc) => { userId = doc.id; });
        if (!userId) { console.error("User ID not found."); return; }
        const couponDocRef = doc(db, `users/${userId}/Coupons`, couponToRemove.couponId);
        await updateDoc(couponDocRef, { status: "ACTIVE", redeemedAt: null, redeemedBy: null, redeemedForMatchId: null, redeemedForMembers: [] });
        Toast.fire({ icon: 'success', title: `‡∏Ñ‡∏π‡∏õ‡∏≠‡∏á ${couponToRemove.reason} ‡∏ñ‡∏π‡∏Å‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô ACTIVE ‡πÅ‡∏•‡πâ‡∏ß!` });
        await fetchCoupons();
        if (matchData) {
            calculateMemberStats(matchData, courtFee, ballPrice, organizeFee, courtFeePerGame, fixedCourtFeePerPerson, updatedAppliedCoupons, earlyPayersList);
        }
        Swal.fire({ title: "‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ñ‡∏π‡∏Å‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÅ‡∏•‡πâ‡∏ß", text: "‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ñ‡πà‡∏≤‡πÉ‡∏ä‡πâ‡∏à‡πà‡∏≤‡∏¢‡∏ñ‡∏π‡∏Å‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÉ‡∏´‡∏°‡πà‡πÇ‡∏î‡∏¢‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡∏Å‡∏î '‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡∏ä‡∏≥‡∏£‡∏∞' ‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á", icon: "info", confirmButtonText: "‡∏£‡∏±‡∏ö‡∏ó‡∏£‡∏≤‡∏ö" });
    } catch (err) {
        console.error("Error setting coupon status back to ACTIVE:", err);
        Swal.fire("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î", `‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Ñ‡∏π‡∏õ‡∏≠‡∏á ${couponToRemove.reason} ‡πÄ‡∏õ‡πá‡∏ô ACTIVE ‡πÑ‡∏î‡πâ: ${err.message}`, "error");
        setAppliedCoupons((prev) => [...prev, couponToRemove]);
    }
  };

  const handleCalculateClick = () => {
    if (!matchData) { Swal.fire("Error", "No match data found for calculation", "error"); return; }
    const isAnyCourtFeeFilled = (courtFee !== "" && parseFloat(courtFee) >= 0) || (courtFeePerGame !== "" && parseFloat(courtFeePerGame) >= 0) || (fixedCourtFeePerPerson !== "" && parseFloat(fixedCourtFeePerPerson) >= 0);
    if (!isAnyCourtFeeFilled) { Swal.fire("Invalid Input", "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏Ñ‡πà‡∏≤‡∏™‡∏ô‡∏≤‡∏°, ‡∏Ñ‡πà‡∏≤‡∏™‡∏ô‡∏≤‡∏°/‡πÄ‡∏Å‡∏°, ‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡πà‡∏≤‡∏™‡∏ô‡∏≤‡∏° (‡∏£‡∏∞‡∏ö‡∏∏‡∏ï‡πà‡∏≠‡∏Ñ‡∏ô) ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÉ‡∏î‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏´‡∏ô‡∏∂‡πà‡∏á ‡πÅ‡∏•‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡πà‡∏≤‡∏ï‡∏¥‡∏î‡∏•‡∏ö", "warning"); return; }
    if (ballPrice === "" || parseFloat(ballPrice) < 0) { Swal.fire("Invalid Input", "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏£‡∏≤‡∏Ñ‡∏≤‡∏•‡∏π‡∏Å‡∏•‡∏∞ ‡πÅ‡∏•‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡πà‡∏≤‡∏ï‡∏¥‡∏î‡∏•‡∏ö", "warning"); return; }
    if (organizeFee === "" || parseFloat(organizeFee) < 0) { Swal.fire("Invalid Input", "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏Ñ‡πà‡∏≤‡∏à‡∏±‡∏î‡∏Å‡πä‡∏ß‡∏ô ‡πÅ‡∏•‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡πà‡∏≤‡∏ï‡∏¥‡∏î‡∏•‡∏ö", "warning"); return; }
    calculateMemberStats(matchData, courtFee, ballPrice, organizeFee, courtFeePerGame, fixedCourtFeePerPerson, appliedCoupons, earlyPayersList);
    Swal.fire({ icon : "success", title: "‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡πà‡∏≤‡πÉ‡∏ä‡πâ‡∏à‡πà‡∏≤‡∏¢‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à", text: "‡πÇ‡∏õ‡∏£‡∏î‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á" });
  };

  const handlePaidStatusChange = useCallback(async (memberName, isPaid) => {
    setMemberPaidStatus((prevStatus) => {
      const newStatus = { ...prevStatus, [memberName]: isPaid };
      setMemberCalculations((prevCalcs) => {
        const updatedCalcs = { ...prevCalcs };
        if (updatedCalcs[memberName]) { updatedCalcs[memberName].isPaid = isPaid; }
        return updatedCalcs;
      });
      return newStatus;
    });
    try {
      const usersRef = collection(db, "users");
      const userQuery = query(usersRef, where("email", "==", loggedInEmail));
      const userSnap = await getDocs(userQuery);
      let userId = null;
      userSnap.forEach((doc) => { userId = doc.id; });
      if (!userId) { throw new Error("User data not found."); }
      const matchDocRef = doc(db, `users/${userId}/Matches`, matchId);
      await updateDoc(matchDocRef, { [`paidStatus.${memberName}`]: isPaid, lastUpdatedPaidStatus: serverTimestamp() });
      Toast.fire({ icon: 'success', title: `‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡∏ä‡∏≥‡∏£‡∏∞‡∏Ç‡∏≠‡∏á ${memberName} ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÅ‡∏•‡πâ‡∏ß!` });
    } catch (err) {
      console.error("Error updating paid status:", err);
      Swal.fire("Error", "Cannot save payment status: " + err.message, "error");
      setMemberPaidStatus((prevStatus) => ({ ...prevStatus, [memberName]: !isPaid }));
      setMemberCalculations((prevCalcs) => {
        const updatedCalcs = { ...prevCalcs };
        if (updatedCalcs[memberName]) { updatedCalcs[memberName].isPaid = !isPaid; }
        return updatedCalcs;
      });
    }
  }, [loggedInEmail, matchId, Toast]);

  const handleSaveToRanking = async () => {
    if (Object.keys(memberCalculations).length === 0) { Swal.fire("Insufficient Data", "Please calculate expenses before saving Ranking data", "warning"); return; }
    if (!matchData || !matchData.matchDate) { Swal.fire("Incomplete Data", "Match date information not found for saving Ranking", "error"); return; }
    setIsSavingRanking(true);
    try {
      const usersRef = collection(db, "users");
      const userQuery = query(usersRef, where("email", "==", loggedInEmail));
      const userSnap = await getDocs(userQuery);
      let userId = null;
      userSnap.forEach((doc) => { userId = doc.id; });
      if (!userId) { throw new Error("User data not found."); }
      const matchDateObj = new Date(matchData.matchDate);
      if (isNaN(matchDateObj.getTime())) { throw new Error("Invalid Match Date."); }
      const monthYearId = `${(matchDateObj.getMonth() + 1).toString().padStart(2, "0")}-${matchDateObj.getFullYear()}`;
      const rankingDocRef = doc(db, `users/${userId}/Ranking`, monthYearId);
      const rankingSnap = await getDoc(rankingDocRef);
      const existingRankingData = rankingSnap.exists() ? rankingSnap.data() : {};
      const updatedRankingData = { ...existingRankingData };
      Object.values(memberCalculations).forEach((member) => {
        const playerName = member.name;
        const prevData = existingRankingData[playerName] || { wins: 0, draws: 0, score: 0, totalGames: 0, totalBalls: 0, level: "" };
        updatedRankingData[playerName] = { wins: prevData.wins + member.calculatedWins, draws: (prevData.draws || 0) + member.calculatedDraws, score: prevData.score + member.calculatedScore, totalGames: prevData.totalGames + member.totalGames, totalBalls: prevData.totalBalls + member.totalBalls, level: member.level || prevData.level || "", lastUpdated: serverTimestamp() };
      });
      updatedRankingData.lastUpdatedMonth = serverTimestamp();
      await setDoc(rankingDocRef, updatedRankingData, { merge: true });
      const matchDocRef = doc(db, `users/${userId}/Matches`, matchId);
      await updateDoc(matchDocRef, { hasRankingSaved: true, lastRankingSavedAt: serverTimestamp() });
      Swal.fire({ icon: "success", title:"‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥ Ranking ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à", text: `‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥ ‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡∏ó‡∏µ‡πà ${monthYearId} ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏≠‡∏¢‡πà‡∏≤‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ã‡πâ‡∏≥!!` });
      setIsRankingSaved(true);
    } catch (err) {
      console.error("Error saving ranking data:", err);
      Swal.fire("Error", "Cannot save Ranking data: " + err.message, "error");
    } finally {
      setIsSavingRanking(false);
    }
  };

  const handleSavePaymentHistory = async () => {
    if (Object.keys(memberCalculations).length === 0) { Swal.fire("Insufficient Data", "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡πà‡∏≤‡πÉ‡∏ä‡πâ‡∏à‡πà‡∏≤‡∏¢‡∏Å‡πà‡∏≠‡∏ô‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡∏ä‡∏≥‡∏£‡∏∞", "warning"); return; }
    if (!matchData || !matchData.matchDate || !matchId) { Swal.fire("Incomplete Data", "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Match ID ‡∏´‡∏£‡∏∑‡∏≠‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà Match ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡∏ä‡∏≥‡∏£‡∏∞", "error"); return; }
    try {
      const usersRef = collection(db, "users");
      const userQuery = query(usersRef, where("email", "==", loggedInEmail));
      const userSnap = await getDocs(userQuery);
      let userId = null;
      userSnap.forEach((doc) => { userId = doc.id; });
      if (!userId) { throw new Error("User data not found."); }
      const totalOverallCost = Object.values(memberCalculations).reduce((sum, m) => sum + m.total, 0);
      const appliedCouponsDetailsForStorage = Object.values(memberCalculations).filter(m => m.couponIdUsed && m.couponAmountUsed > 0).map(m => ({ couponId: m.couponIdUsed, amount: m.couponAmountUsed, memberName: m.name }));
      const paymentHistoryData = {
        matchId: matchId,
        matchDate: matchData.matchDate,
        topic: matchData.topic,
        totalOverall: Math.ceil(totalOverallCost),
        membersData: Object.values(memberCalculations).map((member) => ({ name: member.name, total: member.total, isPaid: member.isPaid, level: member.level, totalGames: member.totalGames, totalBalls: member.totalBalls, ballCost: member.ballCost, courtCostPerPerson: member.courtCostPerPerson, organizeFeePerPerson: member.organizeFeePerPerson, wins: member.wins, draws: member.draws, score: member.score, couponAmountUsed: member.couponAmountUsed || 0, couponIdUsed: member.couponIdUsed || null })),
        lastUpdated: serverTimestamp(),
        appliedCouponsDetails: appliedCouponsDetailsForStorage,
      };
      const paymentHistoryDocRef = doc(db, `users/${userId}/PaymentHistory`, matchId);
      await setDoc(paymentHistoryDocRef, paymentHistoryData, { merge: true });
      const matchDocRef = doc(db, `users/${userId}/Matches`, matchId);
      await updateDoc(matchDocRef, { hasPaymentHistorySaved: true, lastPaymentHistorySavedAt: serverTimestamp(), courtFee: parseFloat(courtFee) || 0, ballPrice: parseFloat(ballPrice) || 0, organizeFee: parseFloat(organizeFee) || 0, courtFeePerGame: parseFloat(courtFeePerGame) || 0, fixedCourtFeePerPerson: parseFloat(fixedCourtFeePerPerson) || 0, appliedCouponsDetails: appliedCouponsDetailsForStorage });
      const uniqueCouponIdsUsed = new Set(appliedCouponsDetailsForStorage.map(c => c.couponId));
      for (const couponId of uniqueCouponIdsUsed) {
        const couponDocRef = doc(db, `users/${userId}/Coupons`, couponId);
        const usedCoupon = availableCoupons.find(c => c.id === couponId);
        await updateDoc(couponDocRef, { status: "USED", redeemedAt: serverTimestamp(), redeemedBy: loggedInEmail, redeemedForMatchId: matchId, redeemedForMembers: appliedCouponsDetailsForStorage.filter(c => c.couponId === couponId).map(c => c.memberName) });
        Toast.fire({ icon: 'info', title: `‡∏Ñ‡∏π‡∏õ‡∏≠‡∏á ${usedCoupon ? usedCoupon.reason : couponId} ‡∏ñ‡∏π‡∏Å‡πÉ‡∏ä‡πâ‡πÅ‡∏•‡πâ‡∏ß!` });
      }
      setAppliedCoupons([]);
      setCurrentCouponSelection({ id: "", amount: 0, reason: "" });
      setCurrentMemberSelection("");
      await fetchCoupons();
      Swal.fire("‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à", "‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô‡∏Ç‡∏≠‡∏á Match ‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÅ‡∏•‡πâ‡∏ß!", "success");
      setIsPaymentHistorySaved(true);
    } catch (err) {
      console.error("Error saving payment history:", err);
      Swal.fire("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î", "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô‡πÑ‡∏î‡πâ: " + err.message, "error");
    }
  };

  const handleExportToExcel = () => {
    if (Object.keys(memberCalculations).length === 0) { Swal.fire("Insufficient Data", "Please calculate expenses before downloading data", "warning"); return; }
    const ws_data = [["No.", "‡∏ä‡∏∑‡πà‡∏≠", "‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏Å‡∏°", "‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏•‡∏π‡∏Å", "‡∏£‡∏≤‡∏Ñ‡∏≤‡∏£‡∏ß‡∏°‡∏•‡∏π‡∏Å‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ", "‡∏Ñ‡πà‡∏≤‡∏™‡∏ô‡∏≤‡∏° (‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢)", "‡∏Ñ‡πà‡∏≤‡∏à‡∏±‡∏î‡∏Å‡πä‡∏ß‡∏ô", "‡∏Ñ‡∏π‡∏õ‡∏≠‡∏á‡∏™‡πà‡∏ß‡∏ô‡∏•‡∏î", "‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ä‡∏ô‡∏∞", "‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏™‡∏°‡∏≠", "‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô", "Total (‡∏ö‡∏≤‡∏ó)", "‡∏à‡πà‡∏≤‡∏¢‡πÅ‡∏•‡πâ‡∏ß"]];
    const sortedMembersForExcel = Object.values(memberCalculations).sort((a, b) => b.score - a.score);
    sortedMembersForExcel.forEach((member, index) => {
      ws_data.push([
        index + 1,
        member.name,
        member.totalGames,
        member.totalBalls,
        member.ballCost,
        member.courtCostPerPerson,
        member.organizeFeePerPerson,
        member.couponAmountUsed > 0 ? member.couponAmountUsed : "-",
        member.wins,
        member.draws,
        member.score,
        member.total,
        member.isPaid ? "‡πÉ‡∏ä‡πà" : "‡πÑ‡∏°‡πà"
      ]);
    });
    if (sortedMembersForExcel.length > 0) {
      ws_data.push(["", "", "", "", "", "", "", "", "", "", "", "Total All:", Math.ceil(Object.values(memberCalculations).reduce((sum, m) => sum + m.total, 0))]);
    }
    const ws = XLSX.utils.aoa_to_sheet(ws_data);
    const centerAlignStyle = { alignment: { horizontal: "center", vertical: "center" } };
    const headerStyle = { font: { bold: true, color: { rgb: "000000" } }, fill: { fgColor: { rgb: "E0E0E0" } }, alignment: { horizontal: "center", vertical: "center" }, border: { top: { style: "thin" }, bottom: { style: "thin" }, left: { style: "thin" }, right: { style: "thin" } } };
    for (let C = 0; C < ws_data[0].length; ++C) {
      const cell = XLSX.utils.encode_cell({ r: 0, c: C });
      if (!ws[cell]) ws[cell] = {};
      ws[cell].s = headerStyle;
    }
    for (let R = 1; R < ws_data.length; ++R) {
      for (let C = 0; C < ws_data[R].length; ++C) {
        const cell = XLSX.utils.encode_cell({ r: R, c: C });
        if (!ws[cell]) ws[cell] = {};
        ws[cell].s = { ...(ws[cell].s || {}), ...centerAlignStyle };
        if (C === 11 && R < ws_data.length - 1) { ws[cell].s = { ...ws[cell].s, font: { color: { rgb: "FF0000" } } }; }
        if (C === 12 && R === ws_data.length - 1) { ws[cell].s = { ...ws[cell].s, font: { bold: true, color: { rgb: "FF0000" } } }; }
        if (C === 11 && R === ws_data.length - 1) { ws[cell].s = { ...ws[cell].s, font: { bold: true }, ...centerAlignStyle }; }
      }
    }
    const colWidths = ws_data[0].map((_, i) => ({ wch: Math.max(...ws_data.map((row) => (row[i] ? String(row[i]).length : 0))) + 2 }));
    ws["!cols"] = colWidths;
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, "Match Details");
    const fileName = `MatchDetails_${matchData?.matchDate ? formatDate(matchData.matchDate).replace(/\//g, "-") : "data"}.xlsx`;
    XLSX.writeFile(wb, fileName);
    Swal.fire("Download Successful", "Excel file downloaded!", "success");
  };

  const handleDownloadImage = async () => {
    if (!tableRef.current || Object.keys(memberCalculations).length === 0) { Swal.fire("‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•", "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡πà‡∏≠‡∏ô‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û", "warning"); return; }
    try {
      setShowDateInDownloadImage(true);
      await new Promise(resolve => setTimeout(resolve, 0));
      const canvas = await html2canvas(tableRef.current, { scale: 2, useCORS: true, backgroundColor: '#ffffff' });
      setShowDateInDownloadImage(false);
      const fileName = `MatchSummary_${matchData?.matchDate ? formatDate(matchData.matchDate).replace(/\//g, "-") : "data"}.png`;
      saveAs(canvas.toDataURL("image/png"), fileName);
      Toast.fire({ icon: 'success', title: '‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!' });
    } catch (error) {
      console.error("Error generating image:", error);
      Swal.fire("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î", "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡πÑ‡∏î‡πâ", "error");
      setShowDateInDownloadImage(false);
    }
  };

  const handleDownloadGameDetailsImage = async () => {
      if (!gameDetailsTableRef.current || !matchData?.matches?.length) { Swal.fire("‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•", "‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏Å‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û", "warning"); return; }
      try {
          const canvas = await html2canvas(gameDetailsTableRef.current, { scale: 2, useCORS: true, backgroundColor: '#ffffff' });
          const fileName = `GameDetails_${matchData?.matchDate ? formatDate(matchData.matchDate).replace(/\//g, "-") : "data"}.png`;
          saveAs(canvas.toDataURL("image/png"), fileName);
          Toast.fire({ icon: 'success', title: '‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡πÄ‡∏Å‡∏°‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!' });
      } catch (error) {
          console.error("Error generating game details image:", error);
          Swal.fire("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î", "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡πÄ‡∏Å‡∏°‡πÑ‡∏î‡πâ", "error");
      }
    };

  const membersWithNoCouponAssigned = Object.values(memberCalculations).filter(member => !appliedCoupons.some(ac => ac.memberName === member.name)).map(member => member.name).sort();
  const unappliedAvailableCoupons = availableCoupons.filter(coupon => !appliedCoupons.some(ac => ac.couponId === coupon.id));

  if (loading) { return (<div style={{ textAlign: "center", padding: "50px" }}>Loading Match Details...</div>); }
  if (error) { return (<div style={{ textAlign: "center", padding: "50px", color: "red" }}>{error}</div>); }
  if (!matchData) { return (<div style={{ textAlign: "center", padding: "50px" }}>No Match Data Found.</div>); }

  const sortedMembers = Object.values(memberCalculations).sort((a, b) => b.score - a.score);
  const totalBallsUsedInGames = matchData.matches?.reduce((sum, game) => sum + (parseInt(game.balls, 10) || 0), 0) || 0;

  return (
    <div style={{ padding: "30px", backgroundColor: "#f7f7f7", minHeight: "100vh", fontFamily: "'Kanit', sans-serif" }}>
      <h1 style={{ fontSize: "24px", marginBottom: "15px" }}>
        ‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î Match ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà {formatDate(matchData.matchDate)}{" "}
        {isRankingSaved && (<span style={{ fontSize: "16px", color: "#28a745", marginLeft: "10px", fontWeight: "normal" }}>(‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å Ranking ‡πÅ‡∏•‡πâ‡∏ß)</span>)}
        {isPaymentHistorySaved && (<span style={{ fontSize: "16px", color: "#17a2b8", marginLeft: "10px", fontWeight: "normal" }}>(‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡∏ä‡∏≥‡∏£‡∏∞‡πÅ‡∏•‡πâ‡∏ß)</span>)}
      </h1>
      <p style={{ fontSize: "16px", marginBottom: "20px", color: "#555" }}>‡∏´‡∏±‡∏ß‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á: {matchData.topic}</p>

      <div style={{ marginBottom: "25px", padding: "20px", border: "1px solid #e0e0e0", borderRadius: "8px", backgroundColor: "#fff" }}>
        <h3 style={{ fontSize: "18px", marginBottom: "15px", borderBottom: "1px solid #eee", paddingBottom: "10px" }}>‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡πà‡∏≤‡πÉ‡∏ä‡πâ‡∏à‡πà‡∏≤‡∏¢</h3>
        <div style={{ marginBottom: "20px", padding: "15px", border: "1px solid #d0d0d0", borderRadius: "5px", backgroundColor: "#f9f9f9" }}>
          <h4 style={{ fontSize: "16px", marginBottom: "10px", color: "#333" }}>‡∏Ñ‡πà‡∏≤‡∏™‡∏ô‡∏≤‡∏° (‡πÄ‡∏•‡∏∑‡∏≠‡∏Å 1 ‡∏ä‡πà‡∏≠‡∏á):</h4>
          <div style={{ display: "flex", gap: "20px", flexWrap: "wrap" }}>
            <div><label style={{ display: "block", marginBottom: "5px", fontSize: "14px", color: "#333" }}>‡∏Ñ‡πà‡∏≤‡∏™‡∏ô‡∏≤‡∏° (‡∏£‡∏ß‡∏°):</label><input type="number" value={courtFee} onChange={handleCourtFeeChange} placeholder="‡∏Ñ‡πà‡∏≤‡∏™‡∏ô‡∏≤‡∏°‡∏£‡∏ß‡∏°" style={{ padding: "8px 12px", borderRadius: "5px", border: "1px solid #ccc", fontSize: "15px", width: "120px" }}/></div>
            <div><label style={{ display: "block", marginBottom: "5px", fontSize: "14px", color: "#333" }}>‡∏Ñ‡πà‡∏≤‡∏™‡∏ô‡∏≤‡∏°/‡πÄ‡∏Å‡∏°:</label><input type="number" value={courtFeePerGame} onChange={handleCourtFeePerGameChange} placeholder="‡∏Ñ‡πà‡∏≤‡∏™‡∏ô‡∏≤‡∏°/‡πÄ‡∏Å‡∏°" style={{ padding: "8px 12px", borderRadius: "5px", border: "1px solid #ccc", fontSize: "15px", width: "120px" }}/></div>
            <div><label style={{ display: "block", marginBottom: "5px", fontSize: "14px", color: "#333" }}>‡∏Ñ‡πà‡∏≤‡∏™‡∏ô‡∏≤‡∏° (‡∏£‡∏∞‡∏ö‡∏∏‡∏ï‡πà‡∏≠‡∏Ñ‡∏ô):</label><input type="number" value={fixedCourtFeePerPerson} onChange={handleFixedCourtFeePerPersonChange} placeholder="‡∏Ñ‡πà‡∏≤‡∏™‡∏ô‡∏≤‡∏°‡∏ï‡πà‡∏≠‡∏Ñ‡∏ô" style={{ padding: "8px 12px", borderRadius: "5px", border: "1px solid #ccc", fontSize: "15px", width: "120px" }}/></div>
          </div>
        </div>
        <div style={{ marginBottom: "20px", padding: "15px", border: "1px solid #d0d0d0", borderRadius: "5px", backgroundColor: "#f9f9f9" }}>
          <h4 style={{ fontSize: "16px", marginBottom: "10px", color: "#333" }}>‡∏Ñ‡πà‡∏≤‡∏•‡∏π‡∏Å‡πÅ‡∏•‡∏∞‡∏Ñ‡πà‡∏≤‡∏à‡∏±‡∏î‡∏Å‡πä‡∏ß‡∏ô:</h4>
          <div style={{ display: "flex", gap: "20px", flexWrap: "wrap", marginBottom: "15px" }}>
            <div><label style={{ display: "block", marginBottom: "5px", fontSize: "14px", color: "#333" }}>‡∏£‡∏≤‡∏Ñ‡∏≤‡∏•‡∏π‡∏Å‡∏•‡∏∞:</label><input type="number" value={ballPrice} onChange={(e) => setBallPrice(e.target.value)} placeholder="‡∏£‡∏≤‡∏Ñ‡∏≤‡∏•‡∏π‡∏Å‡∏•‡∏∞" style={{ padding: "8px 12px", borderRadius: "5px", border: "1px solid #ccc", fontSize: "15px", width: "120px" }} /></div>
            <div><label style={{ display: "block", marginBottom: "5px", fontSize: "14px", color: "#333" }}>‡∏Ñ‡πà‡∏≤‡∏à‡∏±‡∏î‡∏Å‡πä‡∏ß‡∏ô:</label><input type="number" value={organizeFee} onChange={(e) => setOrganizeFee(e.target.value)} placeholder="‡∏Ñ‡πà‡∏≤‡∏à‡∏±‡∏î‡∏Å‡πä‡∏ß‡∏ô" style={{ padding: "8px 12px", borderRadius: "5px", border: "1px solid #ccc", fontSize: "15px", width: "120px" }} /></div>
          </div>
          <div style={{ padding: "15px", border: "1px dashed #ccc", borderRadius: "5px", backgroundColor: "#f0f0f0", marginTop: "15px" }}>
            <h4 style={{ fontSize: "16px", marginBottom: "10px", color: "#333" }}>‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏π‡∏õ‡∏≠‡∏á‡∏™‡πà‡∏ß‡∏ô‡∏•‡∏î:</h4>
            <div style={{ display: "flex", gap: "10px", flexWrap: "wrap", alignItems: "flex-end" }}>
              <div>
                <label style={{ display: "block", marginBottom: "5px", fontSize: "14px", color: "#333" }}>‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ñ‡∏π‡∏õ‡∏≠‡∏á:</label>
                <select value={currentCouponSelection.id} onChange={(e) => { const couponId = e.target.value; const selected = unappliedAvailableCoupons.find(coupon => coupon.id === couponId); setCurrentCouponSelection(selected ? { id: selected.id, amount: selected.amount, reason: selected.reason } : { id: "", amount: 0, reason: "" }); }} style={{ padding: "8px 12px", borderRadius: "5px", border: "1px solid #ccc", fontSize: "15px", width: "180px" }}>
                  <option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ñ‡∏π‡∏õ‡∏≠‡∏á --</option>
                  {unappliedAvailableCoupons.map(coupon => (<option key={coupon.id} value={coupon.id}>{coupon.reason} ({coupon.amount} ‡∏ö‡∏≤‡∏ó)</option>))}
                </select>
              </div>
              <div>
                <label style={{ display: "block", marginBottom: "5px", fontSize: "14px", color: "#333" }}>‡πÉ‡∏ä‡πâ‡∏Å‡∏±‡∏ö‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å:</label>
                <select value={currentMemberSelection} onChange={(e) => setCurrentMemberSelection(e.target.value)} style={{ padding: "8px 12px", borderRadius: "5px", border: "1px solid #ccc", fontSize: "15px", width: "180px" }}>
                  <option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å --</option>
                  {membersWithNoCouponAssigned.map(memberName => (<option key={memberName} value={memberName}>{memberName}</option>))}
                </select>
              </div>
              <button onClick={handleAddCoupon} style={{ backgroundColor: "#17a2b8", color: "#fff", padding: "8px 15px", borderRadius: "5px", border: "none", cursor: "pointer", fontSize: "14px" }}>‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏π‡∏õ‡∏≠‡∏á</button>
            </div>
            {appliedCoupons.length > 0 && (
              <div style={{ marginTop: "15px", borderTop: "1px solid #eee", paddingTop: "10px" }}>
                <h5 style={{ fontSize: "15px", marginBottom: "8px", color: "#555" }}>‡∏Ñ‡∏π‡∏õ‡∏≠‡∏á‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡πÄ‡∏ã‡∏™‡∏ä‡∏±‡∏ô‡∏ô‡∏µ‡πâ:</h5>
                <ul style={{ listStyle: "none", padding: 0 }}>
                  {appliedCoupons.map((item, index) => (<li key={index} style={{ background: "#e9ecef", padding: "8px", borderRadius: "4px", marginBottom: "5px", display: "flex", justifyContent: "space-between", alignItems: "center" }}><span>{item.reason} ({item.amount} ‡∏ö‡∏≤‡∏ó) ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö {item.memberName}</span><button onClick={() => handleRemoveAppliedCoupon(index)} style={{ background: "#dc3545", color: "white", border: "none", borderRadius: "3px", padding: "5px 8px", cursor: "pointer", fontSize: "12px" }}>X</button></li>))}
                </ul>
              </div>
            )}
          </div>
        </div>
        <div style={{ display: "flex", justifyContent: "flex-end", gap: "10px", marginTop: "15px" }}>
          <button onClick={handleCalculateClick} style={{ backgroundColor: "#17a2b8", color: "#fff", padding: "10px 20px", borderRadius: "5px", border: "none", cursor: "pointer", fontSize: "15px" }}>‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡πà‡∏≤‡πÉ‡∏ä‡πâ‡∏à‡πà‡∏≤‡∏¢</button>
        </div>
        <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", gap: "10px", marginTop: "15px", paddingTop: "15px", borderTop: "1px solid #eee" }}>
          <div>
            {isDataCalculated && (
              <button onClick={handleExportToExcel} style={{ backgroundColor: "#4bf196", color: "#fff", padding: "10px 20px", borderRadius: "5px", border: "none", cursor: "pointer", fontSize: "15px" }}>
                ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î Excel
              </button>
            )}
          </div>
          <div style={{ display: "flex", gap: "10px" }}>
            {isDataCalculated && (
              <button onClick={handleSaveToRanking} disabled={isSavingRanking} style={{ backgroundColor: "#d33", color: "#fff", padding: "10px 20px", borderRadius: "5px", border: "none", cursor: "pointer", fontSize: "15px", opacity: isSavingRanking ? 0.7 : 1 }}>
                {isSavingRanking ? (<><span className="spinner"></span> ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å...</>) : ("‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Ranking")}
              </button>
            )}
            {isDataCalculated && (
              <button onClick={handleSavePaymentHistory} style={{ backgroundColor: "#4bf196", color: "#fff", padding: "10px 20px", borderRadius: "5px", border: "none", cursor: "pointer", fontSize: "15px" }}>
                ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡∏ä‡∏≥‡∏£‡∏∞
              </button>
            )}
          </div>
        </div>
      </div>

      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '10px' }}>
        <div>
          {isDataCalculated && (
            <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
              <label htmlFor="mvp-select" style={{ fontSize: '14px', fontWeight: 'bold' }}>‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏à‡∏≥‡∏ô‡∏ß‡∏ô MVP:</label>
              <select 
                id="mvp-select"
                value={mvpCount}
                onChange={(e) => setMvpCount(Number(e.target.value))}
                style={{ padding: '6px 10px', borderRadius: '5px', border: '1px solid #ccc', fontSize: '14px' }}
              >
                {[...Array(10).keys()].map(n => (
                  <option key={n + 1} value={n + 1}>{n + 1}</option>
                ))}
              </select>
            </div>
          )}
        </div>
        <div style={{ display: 'flex', justifyContent: 'flex-end' }}>
            {isDataCalculated && (
                <button onClick={handleDownloadImage} title="Download as Image" style={{ background: '#ffffff', border: '1px solid #ddd', borderRadius: '50%', width: '36px', height: '36px', cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'center', boxShadow: '0 1px 4px rgba(0,0,0,0.1)', transition: 'all 0.2s ease-in-out' }} onMouseOver={e => { e.currentTarget.style.backgroundColor = '#f5f5f5'; e.currentTarget.style.transform = 'scale(1.1)'; }} onMouseOut={e => { e.currentTarget.style.backgroundColor = '#ffffff'; e.currentTarget.style.transform = 'scale(1.0)'; }}>
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#555" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
                </button>
            )}
        </div>
      </div>


      <div ref={tableRef} style={{ overflowX: "auto", border: "1px solid #e0e0e0", borderRadius: "8px", backgroundColor: "#fff", padding: '12px' }}>
        {showDateInDownloadImage && (<div style={{ padding: "8px 0", marginBottom: "10px", fontSize: "16px", fontWeight: "bold", textAlign: "left", color: "#333", borderBottom: "1px solid #eee" }}>‡∏™‡∏£‡∏∏‡∏õ‡∏Ñ‡πà‡∏≤‡πÉ‡∏ä‡πâ‡∏à‡πà‡∏≤‡∏¢ Match ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà: {formatDate(matchData.matchDate)}</div>)}
        <table style={{ width: "100%", borderCollapse: "collapse", fontSize: "14px" }}>
          <thead>
            <tr style={{ backgroundColor: "#323943", color: "white" }}>
              <th style={{ padding: "12px 10px", borderRight: "1px solid #444", textAlign: "center" }}>No.</th>
              <th style={{ padding: "12px 10px", borderRight: "1px solid #444", textAlign: "left" }}>‡∏ä‡∏∑‡πà‡∏≠</th>
              <th style={{ padding: "12px 10px", borderRight: "1px solid #444", textAlign: "center" }}>‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏Å‡∏°</th>
              <th style={{ padding: "12px 10px", borderRight: "1px solid #444", textAlign: "center" }}>‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏•‡∏π‡∏Å</th>
              <th style={{ padding: "12px 10px", borderRight: "1px solid #444", textAlign: "center" }}>‡∏£‡∏≤‡∏Ñ‡∏≤‡∏£‡∏ß‡∏°‡∏•‡∏π‡∏Å‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ</th>
              <th style={{ padding: "12px 10px", borderRight: "1px solid #444", textAlign: "center" }}>‡∏Ñ‡πà‡∏≤‡∏™‡∏ô‡∏≤‡∏° (‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢)</th>
              <th style={{ padding: "12px 10px", borderRight: "1px solid #444", textAlign: "center" }}>‡∏Ñ‡πà‡∏≤‡∏à‡∏±‡∏î‡∏Å‡πä‡∏ß‡∏ô</th>
              <th style={{ padding: "12px 10px", borderRight: "1px solid #444", textAlign: "center" }}>‡∏Ñ‡∏π‡∏õ‡∏≠‡∏á‡∏™‡πà‡∏ß‡∏ô‡∏•‡∏î</th>
              <th style={{ padding: "12px 10px", borderRight: "1px solid #444", textAlign: "center" }}>‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ä‡∏ô‡∏∞</th>
              <th style={{ padding: "12px 10px", borderRight: "1px solid #444", textAlign: "center" }}>‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏™‡∏°‡∏≠</th>
              <th style={{ padding: "12px 10px", borderRight: "1px solid #444", textAlign: "center" }}>‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô</th>
              <th style={{ padding: "12px 10px", borderRight: "1px solid #444", textAlign: "center" }}>Total (‡∏ö‡∏≤‡∏ó)</th>
              <th style={{ padding: "12px 10px", textAlign: "center" }}>‡∏à‡πà‡∏≤‡∏¢‡πÅ‡∏•‡πâ‡∏ß</th>
            </tr>
          </thead>
          <tbody>
            {Object.keys(memberCalculations).length === 0 ? (
              <tr><td colSpan={"13"} style={{ textAlign: "center", padding: "20px", color: "#777" }}>{isDataCalculated ? "‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì" : "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏Å‡∏£‡∏≠‡∏Å‡∏Ñ‡πà‡∏≤‡πÉ‡∏ä‡πâ‡∏à‡πà‡∏≤‡∏¢‡πÅ‡∏•‡πâ‡∏ß‡∏Å‡∏î '‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡πà‡∏≤‡πÉ‡∏ä‡πâ‡∏à‡πà‡∏≤‡∏¢' ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î"}</td></tr>
            ) : (
              sortedMembers.map((member, index) => (
                <tr key={member.name || index} style={{ borderBottom: "1px solid #eee", backgroundColor: index < mvpCount ? "#FFFACD" : "inherit" }}>
                  <td style={{ padding: "10px", borderRight: "1px solid #eee", textAlign: "center" }}>{index + 1}</td>
                  <td style={{ padding: "10px", borderRight: "1px solid #eee", textAlign: "left", fontWeight: "bold" }}>
                    {index < mvpCount && (<span style={{ marginRight: "5px", fontSize: "16px" }}>{getMvpIcon(index + 1)}</span>)}
                    {member.name}
                  </td>
                  <td style={{ padding: "10px", borderRight: "1px solid #eee", textAlign: "center" }}>{member.totalGames}</td>
                  <td style={{ padding: "10px", borderRight: "1px solid #eee", textAlign: "center" }}>{member.totalBalls}</td>
                  <td style={{ padding: "10px", borderRight: "1px solid #eee", textAlign: "center" }}>{member.ballCost}</td>
                  <td style={{ padding: "10px", borderRight: "1px solid #eee", textAlign: "center" }}>{member.courtCostPerPerson}</td>
                  <td style={{ padding: "10px", borderRight: "1px solid #eee", textAlign: "center" }}>{member.organizeFeePerPerson}</td>
                  <td style={{ padding: "10px", borderRight: "1px solid #eee", textAlign: "center" }}>{member.couponAmountUsed > 0 ? member.couponAmountUsed : "-"}</td>
                  <td style={{ padding: "10px", borderRight: "1px solid #eee", textAlign: "center" }}>{member.wins}</td>
                  <td style={{ padding: "10px", borderRight: "1px solid #eee", textAlign: "center" }}>{member.draws}</td>
                  <td style={{ padding: "10px", borderRight: "1px solid #eee", textAlign: "center" }}>{member.score}</td>
                  <td style={{ padding: "10px", borderRight: "1px solid #eee", textAlign: "center", fontWeight: "bold", color: "#e63946" }}>{member.total}</td>
                  <td style={{ padding: "10px", textAlign: "center" }}><input type="checkbox" checked={memberPaidStatus[member.name] || false} onChange={(e) => handlePaidStatusChange(member.name, e.target.checked)} style={{ cursor: "pointer", transform: "scale(1.2)" }} /></td>
                </tr>
              ))
            )}
            {Object.keys(memberCalculations).length > 0 && (
              <tr style={{ backgroundColor: "#f0f0f0", fontWeight: "bold" }}>
                <td colSpan={"11"} style={{ padding: "10px", textAlign: "right", borderRight: "1px solid #eee" }}>Total All:</td>
                <td style={{ padding: "10px", textAlign: "center", color: "#e63946" }}>{Math.ceil(Object.values(memberCalculations).reduce((sum, m) => sum + m.total, 0))}</td>
                <td style={{ padding: "10px", textAlign: "center" }}></td>
              </tr>
            )}
          </tbody>
        </table>
      </div>

      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginTop: '30px', borderBottom: '1px solid #eee', paddingBottom: '10px', marginBottom: '15px' }}>
        <h3 style={{ fontSize: "18px", margin: 0 }}>‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡πÄ‡∏Å‡∏°:</h3>
        <div>
          {matchData.matches && matchData.matches.length > 0 && (
            <button onClick={handleDownloadGameDetailsImage} title="Download Game Details as Image" style={{ background: '#ffffff', border: '1px solid #ddd', borderRadius: '50%', width: '36px', height: '36px', cursor: 'pointer', display: 'flex', alignItems: 'center', justifyContent: 'center', boxShadow: '0 1px 4px rgba(0,0,0,0.1)', transition: 'all 0.2s ease-in-out' }} onMouseOver={e => { e.currentTarget.style.backgroundColor = '#f5f5f5'; e.currentTarget.style.transform = 'scale(1.1)'; }} onMouseOut={e => { e.currentTarget.style.backgroundColor = '#ffffff'; e.currentTarget.style.transform = 'scale(1.0)'; }}>
              <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#555" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
            </button>
          )}
        </div>
      </div>
      <div style={{ marginBottom: "30px" }}>
        {/* --- START: MODIFIED GAME DETAILS TABLE --- */}
        <div ref={gameDetailsTableRef} style={{ overflowX: "auto", border: "1px solid #e0e0e0", borderRadius: "8px", backgroundColor: "#fff", padding: '12px' }}>
          <table style={{ width: "100%", borderCollapse: "collapse", fontSize: "14px" }}>
            <thead>
              <tr style={{ backgroundColor: "#323943", color: "white" }}>
                <th style={{ padding: "12px 10px", borderRight: "1px solid #444", textAlign: "center" }}>No.</th>
                <th style={{ padding: "12px 10px", borderRight: "1px solid #444", textAlign: "center" }}>Match ID</th>
                <th style={{ padding: "12px 10px", borderRight: "1px solid #444", textAlign: "center" }}>‡∏™‡∏ô‡∏≤‡∏°</th>
                <th style={{ padding: "12px 10px", borderRight: "1px solid #444", textAlign: "center" }}>‡∏ó‡∏µ‡∏° A</th>
                <th style={{ padding: "12px 10px", borderRight: "1px solid #444", textAlign: "center" }}>‡∏ó‡∏µ‡∏° B</th>
                <th style={{ padding: "12px 10px", borderRight: "1px solid #444", textAlign: "center" }}>‡∏•‡∏π‡∏Å‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ</th>
                <th style={{ padding: "12px 10px", borderRight: "1px solid #444", textAlign: "center" }}>‡∏ú‡∏•</th>
                <th style={{ padding: "12px 10px", borderRight: "1px solid #444", textAlign: "center" }}>‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏î‡∏¥‡∏ö</th>
                <th style={{ padding: "12px 10px", textAlign: "center" }}>Score</th>
              </tr>
            </thead>
            <tbody>
              {matchData.matches && matchData.matches.length > 0 ? (
                matchData.matches.map((game, index) => {
                  const rawScoreSet1 = (game.A_set1 !== undefined && game.B_set1 !== undefined) ? `${game.A_set1}-${game.B_set1}` : null;
                  const rawScoreSet2 = (game.A_set2 !== undefined && game.B_set2 !== undefined) ? `${game.A_set2}-${game.B_set2}` : null;
                  const rawScoreDisplay = [rawScoreSet1, rawScoreSet2].filter(Boolean).join(", ") || "-";

                  return (
                    <tr key={index} style={{ borderBottom: "1px solid #eee" }}>
                      <td style={{ padding: "10px", borderRight: "1px solid #eee", textAlign: "center" }}>{index + 1}</td>
                      <td style={{ padding: "10px", borderRight: "1px solid #eee", textAlign: "center" }}>{game.matchId || ""}</td>
                      <td style={{ padding: "10px", borderRight: "1px solid #eee", textAlign: "center" }}>{game.court || ""}</td>
                      <td style={{ padding: "10px", borderRight: "1px solid #eee", textAlign: "center" }}>{game.A1 || ""}, {game.A2 || ""}</td>
                      <td style={{ padding: "10px", borderRight: "1px solid #eee", textAlign: "center" }}>{game.B1 || ""}, {game.B2 || ""}</td>
                      <td style={{ padding: "10px", borderRight: "1px solid #eee", textAlign: "center" }}>{game.balls || ""}</td>
                      <td style={{ padding: "10px", borderRight: "1px solid #eee", textAlign: "center" }}>{game.result || ""}</td>
                      <td style={{ padding: "10px", borderRight: "1px solid #eee", textAlign: "center", color: '#007bff', fontWeight: '500' }}>{rawScoreDisplay}</td>
                      <td style={{ padding: "10px", textAlign: "center" }}>{game.score || ""}</td>
                    </tr>
                  )
                })
              ) : (
                <tr><td colSpan="9" style={{ textAlign: "center", padding: "20px", color: "#777" }}>‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡πÄ‡∏Å‡∏°‡πÉ‡∏ô Match ‡∏ô‡∏µ‡πâ.</td></tr>
              )}
            </tbody>
            {matchData.matches && matchData.matches.length > 0 && (
              <tfoot>
                <tr style={{ backgroundColor: "#f0f0f0", fontWeight: "bold" }}>
                  <td colSpan={5} style={{ padding: "10px", textAlign: "right", borderRight: "1px solid #eee" }}>‡∏£‡∏ß‡∏°‡∏•‡∏π‡∏Å‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î:</td>
                  <td style={{ padding: "10px", textAlign: "center", color: "#e63946" }}>{totalBallsUsedInGames}</td>
                  <td colSpan={3} style={{ padding: "10px" }}></td>
                </tr>
              </tfoot>
            )}
          </table>
        </div>
        {/* --- END: MODIFIED GAME DETAILS TABLE --- */}
      </div>

      <style jsx>{`
        @keyframes spinner {
          to { transform: rotate(360deg); }
        }
        .spinner {
          display: inline-block; width: 1em; height: 1em; vertical-align: middle;
          border: 0.15em solid currentColor; border-right-color: transparent;
          border-radius: 50%; animation: spinner 0.75s linear infinite;
        }
      `}</style>
    </div>
  );
};

export default MatchDetails;
